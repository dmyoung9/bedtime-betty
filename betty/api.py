import base64
import contextlib
from functools import wraps
from typing import AsyncGenerator, Iterable
import re

import openai
import tiktoken
import yaml
import json

from .types import API, Message, Role

MODEL = "gpt-3.5-turbo-0301"


def guard_errors(func):
    """A decorator function that handles OpenAI API errors."""

    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except openai.error.APIError as e:
            # Handle API error here, e.g. retry or log
            print(f"OpenAI API returned an API Error: {e}")
        except openai.error.APIConnectionError as e:
            # Handle connection error here
            print(f"Failed to connect to OpenAI API: {e}")
        except openai.error.RateLimitError as e:
            # Handle rate limit error (we recommend using exponential backoff)
            print(f"OpenAI API request exceeded rate limit: {e}")

    return wrapper


def count_tokens(text: str, model: str = MODEL) -> int:
    """Returns the number of tokens in the given text,
    according to the specified model's tokenization rules."""

    encoding = tiktoken.encoding_for_model(model)
    return len(encoding.encode(text))


def parse_yaml_object(response_text):
    try:
        return yaml.safe_load(response_text)
    except yaml.YAMLError:
        return None


def extract_json(string):
    if json_match := re.search(r"\{.*\}|\[.*\]", string, re.DOTALL):
        try:
            return json.loads(json_match.group())
        except json.JSONDecodeError:
            print("Decoding JSON has failed")
            return None
    else:
        print("No JSON object found in the string")
        return None


def system(content: str) -> Message:
    """Creates a system message with the given content."""

    return OpenAI.message("system", content)


def assistant(content: str) -> Message:
    """Creates an assistant message with the given content."""

    return OpenAI.message("assistant", content)


def user(content: str) -> Message:
    """Creates a user message with the given content."""
    # noqa: F821
    return OpenAI.message("user", content)


class OpenAI(API):
    """A class that provides methods for interacting with the OpenAI API."""

    def __init__(self, api_key: str):
        openai.api_key = api_key

    @staticmethod
    def message(role: Role, content: str) -> Message:
        """Creates a message with the given role and content."""

        return {"role": role, "content": content}

    @guard_errors
    async def get_completion(
        self,
        messages: Iterable[Message],
        model: str = MODEL,
        temperature: float = 1,
    ) -> str:
        """Returns the text generated by the model based on the given messages."""

        response = await openai.ChatCompletion.acreate(
            model=model,
            messages=messages,
            temperature=temperature,
            stream=False,
        )

        return response["choices"][0]["message"]["content"]

    @guard_errors
    async def stream_completion(
        self,
        messages: Iterable[Message],
        model: str = MODEL,
        temperature: float = 1,
    ) -> AsyncGenerator[str, None]:
        """Streams the generated text in chunks based on the given messages."""

        response = await openai.ChatCompletion.acreate(
            model=model,
            messages=messages,
            temperature=temperature,
            stream=True,
        )

        async for chunk in response:
            yield chunk["choices"][0]["delta"]

    @guard_errors
    async def stream_yaml(
        self,
        messages: Iterable[Message],
        model: str = MODEL,
        temperature: float = 1,
        separator: str = r"\n\n",
    ) -> AsyncGenerator[str, None]:
        """Streams the generated text in chunks based on the given messages."""

        response = self.stream_completion(
            model=model,
            messages=messages,
            temperature=temperature,
        )

        buffer = ""

        # Regex pattern to identify the start of a new object
        end_of_object_pattern = re.compile(separator)

        async for chunk in response:
            buffer += chunk.get("content", "")
            match = end_of_object_pattern.search(buffer)

            while match is not None:
                complete_yaml_object = buffer[: match.end() - 1]
                parsed_yaml = parse_yaml_object(complete_yaml_object)

                if parsed_yaml is not None:
                    yield parsed_yaml[0] if isinstance(
                        parsed_yaml, list
                    ) else parsed_yaml

                buffer = buffer[match.end() :]
                match = end_of_object_pattern.search(buffer)

        if buffer:
            parsed_yaml = parse_yaml_object(buffer)
            if parsed_yaml is not None:
                yield parsed_yaml[0]

    @guard_errors
    async def stream_json(
        self,
        messages: Iterable[Message],
        model: str = MODEL,
        temperature: float = 1,
    ) -> AsyncGenerator[dict, None]:
        """Streams the generated text in chunks based on the given messages."""

        response = self.stream_completion(
            model=model,
            messages=messages,
            temperature=temperature,
        )

        buffer = ""
        open_brackets = 0
        start = 0
        started = False

        async for chunk in response:
            buffer += chunk.get("content", "")

            while buffer:
                if not started:
                    # Try to find the start of a JSON object
                    try:
                        start = buffer.index("{")
                        buffer = buffer[start:]
                        started = True
                        open_brackets = 1
                    except ValueError:
                        # No JSON object in buffer, so clear it
                        buffer = ""
                else:
                    # Look for the end of the JSON object
                    for i, char in enumerate(buffer[1:], start=1):
                        if char == "{":
                            open_brackets += 1
                        elif char == "}":
                            open_brackets -= 1
                            if open_brackets == 0:
                                json_str = buffer[: i + 1]
                                yield json.loads(json_str)
                                buffer = buffer[i + 1 :]
                                started = False
                                break
                    else:
                        # No complete JSON object found, so break out of the loop
                        # and wait for more chunks
                        break

    @guard_errors
    async def get_image(
        self, prompt: str, size: int = 1024, response_format="url"
    ) -> str:
        """Returns an image generated based on the given prompt and parameters."""

        image_response = await openai.Image.acreate(
            prompt=prompt, n=1, size=f"{size}x{size}", response_format=response_format
        )

        content = image_response["data"][0][response_format]
        return base64.b64decode(content) if response_format == "b64_json" else content
